"""
http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
"""

from botocore.vendored import requests
import boto3
import json
import string
import random
import resource_tools


def event_handler(event, context):
    """
    Lambda entry point. Print the event first.
    """
    print("Event Input: %s" % json.dumps(event))
    try:
        medialive = boto3.client('medialive')
        if event["RequestType"] == "Create":
            result = create_input(medialive, event, context)
        elif event["RequestType"] == "Update":
            result = update_input(medialive, event, context)
        elif event["RequestType"] == "Delete":
            result = delete_input(medialive, event, context)
    except Exception as exp:
        print("Exception: %s" % exp)
        result = {
            'Status': 'FAILED',
            'Data': {"Exception": str(exp)},
            'ResourceId': None
        }
    if 'ResponseURL' in event:
        resource_tools.send(event, context, result['Status'],
                        result['Data'], result['ResourceId'])
    return result


def create_input(medialive, event, context, auto_id=True):
    """
    Create a MediaLive input
    """

    if auto_id:
        input_id = "%s-%s" % (resource_tools.stack_name(event),
                              event["LogicalResourceId"])
    else:
        input_id = event["PhysicalResourceId"]

    try:
        response = medialive.create_input(
            Name=input_id,
            Type="%s" % event["ResourceProperties"]["InputType"],
            InputSecurityGroups = event["ResourceProperties"]["InputSecurityGroup"]
        )

        print(json.dumps(response))

        # wait for the new input to reach detached state
        resource_tools.wait_for_input_states(medialive, response['Input']['Id'], ['DETACHED'])

        result = {
            'Status': 'SUCCESS',
            'Data': response,
            'ResourceId': response['Input']['Id']
        }

    except Exception as ex:
        print(ex)
        result = {
            'Status': 'FAILED',
            'Data': {"Exception": str(ex)},
            'ResourceId': response['Input']['Id']
        }

    return result


def update_input(medialive, event, context):
    """
    Update a MediaPackage channel
    Return the channel URL, username and password generated by MediaPackage
    """

    channel_id = event["PhysicalResourceId"]

    try:
        result = delete_input(medialive, event, context)
        if result['Status'] == 'SUCCESS':
            result = create_input(medialive, event, context, False)

    except Exception as ex:
        print(ex)
        result = {
            'Status': 'FAILED',
            'Data': {"Exception": str(ex)},
            'ResourceId': channel_id
        }

    return result


def delete_input(medialive, event, context):
    """
    Delete a MediaLive input source
    Return success/failure
    """
    if 'PhysicalResourceId' in event:
        input_id = event["PhysicalResourceId"]
    else:
        input_id = event["ResourceProperties"]["MediaLiveInputId"]

    try:
        # wait for the input to be detached
        resource_tools.wait_for_input_states(medialive, input_id, ['DETACHED'])
        medialive.delete_input(InputId=input_id)
        result = {
            'Status': 'SUCCESS',
            'Data': {},
            'ResourceId': input_id
        }

    except Exception as ex:
        print(ex)
        result = {
            'Status': 'FAILED',
            'Data': {"Exception": str(ex)},
            'ResourceId': input_id
        }

    return result
